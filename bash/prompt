
# truncates a string on the left
# $1: string to truncate
# $2: maximum length
# $3: truncation string replacement (optional)
# $4: separator symbol (optional, prevents truncation of rightmost item)
__truncate_left() {
    local str="$1"
    local maxlen="$2"
    local trunc_symbol="$3"
    local sep_symbol="$4"

    # get minimum length to not truncate a long name
    if [ -n "$sep_symbol" ]
    then
        local component=${1##*$sep_symbol}
        maxlen=$(( ( maxlen < ${#component} ) ? ${#component} : maxlen ))
    fi

    # truncation point
    local offset=$(( ${#str} - maxlen ))

    if [ ${offset} -gt "0" ]
    then
        #truncation is needed
        str=${str:$offset:$maxlen}  #truncate
        str=${trunc_symbol}/${str#*/}  #add symbol
    fi
    echo "$str"
}

# truncates a path
__truncate_path() {
    #gain some place with '~'
    local path=${1/#$HOME/\~}
    __truncate_left "$path" 25 'â€¦' '/'
}

# truncates CWD
__tpwd() {
    __truncate_path "$PWD"
}

#__print_rprompt() {
#    source "$DOTFILES_BASH_DIR/ansi_colors"
#    local rprompt=""
#    local prompt=""
#    printf "%s%$(($COLUMNS-${#prompt}))s\r" $prompt $rprompt
#}
#PROMPT_COMMAND="$PROMPT_COMMAND __print_rprompt"

__set_bash_ps1() {

    # load color vars
    source "$DOTFILES_BASH_DIR/ansi_colors"

    # colorized:
    PS1=" ${B}[${UC}\u@\h ${G}\$(__tpwd)${B}]${UC}\\$ ${NONE}"
}

__set_bash_ps1
unset __set_bash_ps1

# vim: ft=sh
