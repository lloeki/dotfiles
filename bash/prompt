
# truncates a string on the left
# $1: string to truncate
# $2: maximum length
# $3: truncation string replacement (optional)
# $4: separator symbol (optional, prevents truncation of rightmost item)
__truncate_left() {
    local str="$1"
    local maxlen="$2"
    local trunc_symbol="$3"
    local sep_symbol="$4"

    # get minimum length to not truncate a long name
    if [ -n "$sep_symbol" ]
    then
        local component=${1##*$sep_symbol}
        maxlen=$(( ( maxlen < ${#component} ) ? ${#component} : maxlen ))
    fi

    # truncation point
    local offset=$(( ${#str} - maxlen ))

    if [ ${offset} -gt "0" ]
    then
        #truncation is needed
        str=${str:$offset:$maxlen}  #truncate
        str=${trunc_symbol}/${str#*/}  #add symbol
    fi
    echo "$str"
}

# truncates a path
__truncate_path() {
    #gain some place with '~'
    local path=${1/#$HOME/\~}
    __truncate_left "$path" 25 '…' '/'
}

# truncates CWD
__tpwd() {
    __truncate_path "$PWD"
}

# git prompt info
source $DOTFILES_BASH_DIR/git_prompt_info
GIT_PS1_SHOWDIRTYSTATE=1
GIT_PS1_SHOWSTASHSTATE=1
GIT_PS1_SHOWUNTRACKEDFILES=1

# dynamic prompt
__set_prompt() {
    source "$DOTFILES_BASH_DIR/ansi_colors"
    __git_ps1_vars
    PS1="${B}[${UC}\u@\h"
    if [[ -n "${GIT_PS1_NAME-}" ]]; then
        PS1+=" ${Y}${GIT_PS1_NAME}"
        PS1+="${UC}›${B}${GIT_PS1_BRANCH}"
        PS1+="${UC}›${G}${GIT_PS1_PREFIX}"
        PS1+=" ${UC}(${GIT_PS1_STATUS})"
    else
        PS1+=" ${G}$(__tpwd)"
    fi
    PS1+="${B}]${UC}\\$ ${NONE}"
}
PROMPT_COMMAND="${PROMPT_COMMAND} __set_prompt;"

# vim: ft=sh
