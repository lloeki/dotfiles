# Make Bash more like Zsh


# Hooks
# derived from http://glyf.livejournal.com/63106.html

# default: NOOPs
function preexec { :; }
function precmd  { :; }
function chpwd   { :; }

__cd_invoke_chpwd() {
    builtin cd $@
    chpwd
}

__preexec_invoke_exec () {
    local this_command;

    [ -n "$COMP_LINE" ] && return  # completion
    [ "$BASH_COMMAND" = "$PROMPT_COMMAND" ] && return  # precmd

    this_command=`history 1 | sed -e "s/^[ ]*[0-9]*[ ]*//g"`;
    preexec "$this_command"
}

# set up the hooks
PROMPT_COMMAND="precmd"
trap '__preexec_invoke_exec' DEBUG
cd() { __cd_invoke_chpwd $@; }


# clears a line that was not terminated by a LF
# fixing the dangling prompt issue
# marks it with a reverse %, like zsh
clear_incomplete_line() {
    # ask for cursor position
    echo -en "\033[6n"
    # read answer
    IFS=';' read -r -d R -a pos
    # extract tput-compatible answer
    local row=$((${pos[0]:2} - 1))
    local col=$((${pos[1]} - 1))
    # move back over terminal answer echo, which will hopefully be overwritten
    tput cup $row $col

    # not on first column? clean up! (overwrites answer)
    # we print a terminal width worth of columns, but since 
    # it goes too far, we backtrack with CR
    [[ $col != 0 ]] && printf "\e[7m%%\e[m%*s\r" $((COLUMNS-1))
    # else e.g prompt will overwrite answer echo
}

