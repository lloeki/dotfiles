# finds .git folder
__git_ps1_repo_path() {
    if [ -d .git ]; then
        echo "$(pwd)/.git"
    else
        git rev-parse --git-dir 2>/dev/null
    fi
}

# repo name
__git_ps1_repo_name() {
    basename $(dirname $(__git_ps1_repo_path))
}

# head that's being merged
__git_ps1_rebase_merge_head() {
    cat "$1/rebase-merge/head-name"
}

# describe according to GIT_PS1_DESCRIBE_STYLE
__git_ps1_describe() {
    case "${GIT_PS1_DESCRIBE_STYLE-}" in
        (contains)
            git describe --contains HEAD ;;
        (branch)
            git describe --contains --all HEAD ;;
        (describe)
            git describe HEAD ;;
        (* | default)
            git describe --exact-match HEAD ;;
    esac 2>/dev/null
}

# branch name
__git_ps1_branch() {
    local g="$1"

    local             branch="$(git symbolic-ref HEAD 2>/dev/null)"
    [[ $? -ne 0 ]] && branch="$(__git_ps1_describe)"
    [[ $? -ne 0 ]] && branch="$(git rev-parse --short HEAD)â€¦"
    [[ $? -ne 0 ]] && branch="unknown"

    echo ${branch##refs/heads/}
}

__git_ps1_vars() {
    #local g="$(__gitdir)"
    local g=".git"
    [[ -z "$g" ]] && return

    local rebase=0
    local interactive=0
    local apply=0
    local merge=0
    local bisect=0
    local subject=""
    local branch=""
    local gitdir=0
    local bare=0
    local work=0
    local staged=0
    local unstaged=0
    local initial=0
    local untracked=0
    local stash=0

    [[ -d "$g/rebase-merge" ]] && rebase=1 merge=1 subject=$(__git_ps1_rebase_merge_head)
    [[ $rebase -eq 1 && -f "$g/rebase-merge/interactive" ]] && interactive=1 merge=0
    [[ -d "$g/rebase-apply" ]] && rebase=1 apply=1
    [[ $apply  -eq 1 && -f "$g/rebase-apply/applying" ]] && rebase=0
    [[ $apply  -eq 1 && -f "$g/rebase-apply/rebasing" ]] && apply=0
    [[ $rebase -eq 0 && -f "$g/MERGE_HEAD" ]] && merge=1
    [[ $rebase -eq 0 && -f "$g/BISECT_LOG" ]] && bisect=1

    branch=$(__git_ps1_branch)

    [[ "true" = "$(git rev-parse --is-inside-git-dir 2>/dev/null)" ]] && gitdir=1
    [[ $gitdir -eq 1 && "true" = "$(git rev-parse --is-bare-repository 2>/dev/null)" ]] && bare=1
    [[ $gitdir -eq 0 && "true" = "$(git rev-parse --is-inside-work-tree 2>/dev/null)" ]] && work=1

    if [[ $work -eq 1 ]]; then
        ## dirtiness, if config allows it
        if [ "$(git config --bool bash.showDirtyState)" != "false" ]; then
            # unstaged files
            git diff --no-ext-diff --ignore-submodules --quiet --exit-code || unstaged=1

            if git rev-parse --quiet --verify HEAD >/dev/null; then
                # staged files
                git diff-index --cached --quiet --ignore-submodules HEAD -- || staged=1
            else
                # no current commit, we're fresh
                initial=1
            fi
        fi

        ## stash status
        git rev-parse --verify refs/stash >/dev/null 2>&1 && stash=1

        ## untracked files
        [ -n "$(git ls-files --others --exclude-standard)" ] && untracked=1
    fi

    echo rebase $rebase
    echo interactive $interactive
    echo apply $apply
    echo merge $merge
    echo bisect $bisect
    echo subject $subject
    echo branch $branch
    echo gitdir $gitdir
    echo bare $bare
    echo work $work
    echo staged $staged
    echo unstaged $unstaged
    echo whatever $whatever
    echo untracked $untracked
    echo stash $stash
}

# vim: ft=sh
