# prompt segments: bash and zsh

#POWERLINE_TRI_LEFT_FULL=''
#POWERLINE_TRI_LEFT_EMPTY=''
#POWERLINE_TRI_RIGHT_FULL=''
#POWERLINE_TRI_RIGHT_EMPTY=''
#POWERLINE_BRANCH=''
#POWERLINE_LN=''
#POWERLINE_LOCK=''
#POWERLINE_ASIDE='➦'

POWERLINE_TRI_LEFT_FULL='⮂'
POWERLINE_TRI_LEFT_EMPTY='⮃'
POWERLINE_TRI_RIGHT_FULL='⮀'
POWERLINE_TRI_RIGHT_EMPTY='⮁'
POWERLINE_BRANCH=''
POWERLINE_LN='⭡'
POWERLINE_LOCK='⭤'
POWERLINE_ASIDE='➦'

UNICODE_BOX_VERTICAL_BAR='│'

prompt_is_fancy() {
    [[ $PROMPT_FANCY -eq 1 ]]
}

prompt_setup_segments() {
    if prompt_is_fancy; then
        SEGMENT_SEPARATOR=$POWERLINE_TRI_RIGHT_FULL
        RSEGMENT_SEPARATOR=$POWERLINE_TRI_LEFT_FULL
        SUBSEGMENT_SEPARATOR=$POWERLINE_TRI_RIGHT_EMPTY
        RSUBSEGMENT_SEPARATOR=$POWERLINE_TRI_LEFT_EMPTY
    else
        SEGMENT_SEPARATOR=''
        RSEGMENT_SEPARATOR=''
        SUBSEGMENT_SEPARATOR=$UNICODE_BOX_VERTICAL_BAR
        RSUBSEGMENT_SEPARATOR=$SUBSEGMENT_SEPARATOR
    fi
}

prompt_segment() {
    [[ -z $RPROMPT_SEGMENT ]] && lprompt_segment $@ || rprompt_segment $@
}

prompt_subsegment() {
    local sep
    [[ -z $RPROMPT_SEGMENT ]] && sep=$SUBSEGMENT_SEPARATOR || sep=$RSUBSEGMENT_SEPARATOR
    echo -n " $sep "
    [[ -n $1 ]] && print -Pn $1
}

# vim: ft=sh:
