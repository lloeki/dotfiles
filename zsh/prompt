#source $DOTFILES_ZSH_DIR/prompt_vcs

#POWERLINE_TRI_LEFT_FULL=''
#POWERLINE_TRI_LEFT_EMPTY=''
#POWERLINE_TRI_RIGHT_FULL=''
#POWERLINE_TRI_RIGHT_EMPTY=''
#POWERLINE_BRANCH=''
#POWERLINE_LN=''
#POWERLINE_LOCK=''
#POWERLINE_ASIDE='➦'

POWERLINE_TRI_LEFT_FULL='⮂'
POWERLINE_TRI_LEFT_EMPTY='⮃'
POWERLINE_TRI_RIGHT_FULL='⮀'
POWERLINE_TRI_RIGHT_EMPTY='⮁'
POWERLINE_BRANCH=''
POWERLINE_LN='⭡'
POWERLINE_LOCK='⭤'
POWERLINE_ASIDE='➦'

UNICODE_BOX_VERTICAL_BAR='│'

prompt_is_fancy() {
    [[ $PROMPT_FANCY -eq 1 ]]
}

prompt_setup_segments() {
    if prompt_is_fancy; then
        SEGMENT_SEPARATOR=$POWERLINE_TRI_RIGHT_FULL
        RSEGMENT_SEPARATOR=$POWERLINE_TRI_LEFT_FULL
        SUBSEGMENT_SEPARATOR=$POWERLINE_TRI_RIGHT_EMPTY
        RSUBSEGMENT_SEPARATOR=$POWERLINE_TRI_LEFT_EMPTY
    else
        SEGMENT_SEPARATOR=''
        RSEGMENT_SEPARATOR=''
        SUBSEGMENT_SEPARATOR=$UNICODE_BOX_VERTICAL_BAR
        RSUBSEGMENT_SEPARATOR=$SUBSEGMENT_SEPARATOR
    fi
}

SEGMENT_DEFAULT_BG=15
#SEGMENT_DEFAULT_BG=0
SEGMENT_DEFAULT_FG=14

prompt_segment() {
    [[ -z $RPROMPT_SEGMENT ]] && lprompt_segment $@ || rprompt_segment $@
}

lprompt_segment() {
    local bg fg fake_bg

    [[ -n $1 ]] && bg="$1" || bg='default'
    [[ -n $2 ]] && fg="$2" || fg='default'

    if [[ $CURRENT_BG == 'default' ]]; then
        fake_bg=$SEGMENT_DEFAULT_BG
    else
        fake_bg=$CURRENT_BG
    fi

    if [[ $CURRENT_BG != 'NONE' && $1 != $CURRENT_BG ]]; then
        echo -n " %{%K{$bg}%F{$fake_bg}%}$SEGMENT_SEPARATOR%{%F{$fg}%} "
    else
        echo -n "%{%K{$bg}%}%{%F{$fg}%} "
    fi

    CURRENT_BG=$1
    [[ -n $3 ]] && print -Pn $3
}

prompt_subsegment() {
    echo -n " $SUBSEGMENT_SEPARATOR "
    [[ -n $1 ]] && print -Pn $1
}

# End the prompt, closing any open segments
prompt_end() {
    if [[ -n $CURRENT_BG ]]; then
        echo -n " %{%k%F{$CURRENT_BG}%}$SEGMENT_SEPARATOR"
    else
        echo -n "%{%k%}"
    fi
    echo -n "%{%f%}"
    CURRENT_BG=''
}

rprompt_segment() {
    local bg fg fake_bg prev_bg

    [[ -n $1 ]] && bg="$1" || bg='default'
    [[ -n $2 ]] && fg="$2" || fg='default'

    if [[ $bg == 'default' ]]; then
        fake_bg=$SEGMENT_DEFAULT_BG
    else
        fake_bg=$bg
    fi
    prev_bg=$CURRENT_BG

    if [[ $1 != $CURRENT_BG ]]; then
        echo -n " %{%K{$prev_bg}%F{$fake_bg}%}$RSEGMENT_SEPARATOR%{%K{$bg}%F{$fg}%} "
    else
        echo -n "%{%K{$bg}%}%{%F{$fg}%} "
    fi

    CURRENT_BG=$1
    [[ -n $3 ]] && print -Pn $3
}

rprompt_end() {
    echo -n ' '
    echo -n "%{%k%f%}"
    CURRENT_BG=''
}


prompt_host() {
    if [[ $UID -eq 0 ]]; then
        prompt_segment red white '%n@%m'
    else
        prompt_segment white black '%n@%m'
    fi
}

prompt_dir() {
    prompt_segment green white '%~'
}

prompt_git() {
    __git_ps1_vars
    if [[ -n $GIT_PS1_STATUS ]]; then
        PROMPT_VCS_TYPE='git'
        PROMPT_VCS_REF="$GIT_PS1_BRANCH"
        PROMPT_VCS_WPATH="$GIT_PS1_TOPLEVEL"
        PROMPT_VCS_WNAME="$GIT_PS1_NAME"
        PROMPT_VCS_WPWD="$GIT_PS1_PREFIX"
        [[ "$GIT_PS1_STATUS" == *t* ]] && PROMPT_VCS_DIRTY=1
        [[ "$GIT_PS1_STATUS" == *u* ]] && PROMPT_VCS_DIRTY=1
        [[ "$GIT_PS1_STATUS" == *s* ]] && PROMPT_VCS_DIRTY=1
        return 0
    else
        unset PROMPT_VCS_TYPE
        return 1
    fi
}

prompt_vcs_repo() {
    if prompt_git; then # TODO: || prompt_hg
        local branch_icon repo_color
        if prompt_is_fancy; then
            branch_icon=" $POWERLINE_BRANCH "
        else
            branch_icon=" ⎇ "
        fi

        if [[ $PROMPT_VCS_DIRTY -eq 1 ]]; then
            repo_color=yellow
        else
            repo_color=blue
        fi

        prompt_segment $repo_color white "$PROMPT_VCS_WNAME$branch_icon$PROMPT_VCS_REF"
        [[ -n $PROMPT_VCS_WPWD ]] && prompt_segment green white "$PROMPT_VCS_WPWD"

        return 0
    else
        return 1
    fi

}

prompt_vcs_status() {
    # status symbols
    if prompt_git; then
        local vcs_status=""
        [[ "$GIT_PS1_STATUS" == *h* ]] && vcs_status+="${NONE}↰"
        [[ "$GIT_PS1_STATUS" == *t* ]] && vcs_status+="${R}!"
        [[ "$GIT_PS1_STATUS" == *u* ]] && vcs_status+="${Y}≠"
        [[ "$GIT_PS1_STATUS" == *s* ]] && vcs_status+="${R}±"
        [[ "$GIT_PS1_STATUS" == *n* ]] && vcs_status+="${BB}∅"
        [[ -n "$vcs_status" ]] && prompt_segment white black "${vcs_status}"
    fi
}

prompt_vcs_action() {
    # action info
    if prompt_git; then
        local action=""
        [[ "$GIT_PS1_STATUS" == *R* ]] && action+=" rebase"
        [[ "$GIT_PS1_STATUS" == *i* ]] && action+="-i"
        [[ "$GIT_PS1_STATUS" == *A* ]] && action+=" apply"
        [[ "$GIT_PS1_STATUS" == *M* ]] && action+=" merge"
        [[ "$GIT_PS1_STATUS" == *B* ]] && action+=" bisect"
        [[ -n "$action" ]] && prompt_segment yellow white "$action"
    fi
}

prompt_segment_test() {
    prompt_segment red white
    prompt_segment default white
    prompt_segment blue white
    prompt_segment default white
    prompt_segment green white
    prompt_segment default white
    prompt_segment cyan white
    prompt_segment default white
    prompt_segment yellow white
    prompt_segment default white
    prompt_segment white black
    prompt_segment default white
    prompt_segment black white
    prompt_segment default white
    prompt_segment red white
    prompt_segment default white
    prompt_segment
    CURRENT_BG='NONE'
    echo
}

rprompt_segment_test() {
    rprompt_segment
    rprompt_segment red white
    rprompt_segment default white
    rprompt_segment blue white
    rprompt_segment default white
    rprompt_segment green white
    rprompt_segment default white
    rprompt_segment cyan white
    rprompt_segment default white
    rprompt_segment yellow white
    rprompt_segment default white
    rprompt_segment white black
    rprompt_segment default white
    rprompt_segment black white
    rprompt_segment default white
    rprompt_segment red white
    rprompt_segment default white
    CURRENT_BG='NONE'
    echo
}

prompt_last_rc() {
    #echo -n "%(?..%B[%?]%b)"
    [[ $LAST_CMD_RC -ne 0 ]] && prompt_segment red white "$LAST_CMD_RC"
}

prompt_vi_mode() {
    local mode_color mode_text

    PROMPT_VI_MODE="${${KEYMAP/vicmd/NORMAL}/(main|viins)/INSERT}"

    case $PROMPT_VI_MODE in
        NORMAL)
            mode_color='green'
            mode_text='N'
            ;;
        *)
            mode_color='blue'
            mode_text='I'
            ;;
    esac
    [[ -n $mode_color ]] && prompt_segment $mode_color white $mode_text
}

function zle-line-init zle-keymap-select {
    set_prompt
    set_rprompt
    zle reset-prompt
}
zle -N zle-line-init
zle -N zle-keymap-select

prompt_build() {
    RPROMPT_SEGMENTS=''
    prompt_setup_segments
    CURRENT_BG='NONE'
    prompt_host
    prompt_vcs_repo || prompt_dir
    prompt_end
    echo -n ' '
}

rprompt_build() {
    RPROMPT_SEGMENT=1
    prompt_setup_segments
    CURRENT_BG='NONE'
    prompt_last_rc
    #prompt_vcs_status
    #prompt_vcs_action
    rprompt_end
}

prompt_opts=(cr percent)

set_prompt() {
    PROMPT="$(prompt_build)"
}

set_rprompt() {
    RPROMPT="$(rprompt_build)"
}

# vim: ft=zsh
